\section{Parte I}

\begin{frame}{Recursión Estructural -- \texttt{foldAB}}
    \begin{exampleblock}{Parte I}
        Usando recursión explícita, definir los esquemas de recursión estructural (\code{foldAB}) y primitiva (\code{recAB}), y dar sus tipos.
    \end{exampleblock}

    \pause

    \begin{block}{Tip}
        Antes de definir cualquier función, \alert{dar su tipo}.
    \end{block}

    \pause

    El tipo de la función de recursión estructural \code{foldT} para cualquier \code{T} se puede definir ``automáticamente'' en base a la definición de \code{T}:
    
    \pause

    \begin{itemize}[<+->]
        \item \code{foldT} devuelve un valor de tipo \code{r} y recibe una función \code{f} por cada constructor.
        \item Las funciones reciben los mismos argumentos que los constructores correspondientes, excepto por los \textbf{argumentos recursivos} (los de tipo \code{T}): éstos se reemplazan por resultados de la recursión (de tipo \code{r}).
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Recursión Estructural -- \texttt{foldAB} (Cont.)}
    Repasamos la definición de \code{AB}:

    \begin{minted}{haskell}
        data AB a =
            | Bin (AB a) a (AB a)
            | Nil
    \end{minted}

    \pause

    El método anterior nos dice que el tipo de \code{foldAB} debe ser:
    
    \begin{minted}[escapeinside=||]{haskell}
        foldAB ::|\pause|
            (r -> a -> r -> r) -> -- Caso Bin (AB a) a (AB a)|\pause|
            r ->                  -- Caso Nil|\pause|
            AB a ->               -- Entrada|\pause|
            r                     -- Resultado
    \end{minted}

    \pause

    La definición de la función se desprende casi directamente:
    \begin{minted}[escapeinside=||]{haskell}
        foldAB :: (r -> a -> r -> r) -> r -> AB a -> r|\pause|
        foldAB f z Nil = z|\pause|
        foldAB f z (Bin izq val der) = f (rec izq) val (rec der)|\pause|
            where rec ab = foldAB f z ab
    \end{minted}
\end{frame}

\begin{frame}[fragile]{Recursión Primitiva -- \texttt{recAB}}
    El esquema de \textbf{recursión primitiva} se puede armar a partir del de \textbf{recursión estructural}: en las funciones que reciben \textbf{resultados recursivos}, se agrega también el argumento recursivo del que viene el resultado.

    \pause

    Definamos entonces \code{recAB}:

    \pause
    
    \begin{minted}[fontsize=\small,escapeinside=||]{haskell}
        recAB :: (|\textcolor{red}{\textbf{AB} a}| -> r -> a -> |\textcolor{red}{\textbf{AB} a}| -> r -> r) -> r -> AB a -> r|\pause|
        recAB f z Nil = z|\pause|
        recAB f z (Bin izq val der) = f izq (rec izq) val der (rec der)|\pause|
            where rec ab = recAB f z ab
    \end{minted}
\end{frame}
